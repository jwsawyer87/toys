#! /usr/bin/env python

import re
import sys
import getopt
import subprocess

"""
(usp-venv-2017-06-07)[10:12:13][jpfuntne<ao-dev>@bxb-mitg7-dev23:/nobackup/jpfuntne/master/usp/uas]$ git status uas
On branch US39053-AutoDeploy_AutoVNF_support
Your branch is up-to-date with 'origin/US39053-AutoDeploy_AutoVNF_support'.
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        modified:   uas/uspc.py
        modified:   uas/workers/dep_worker.py

no changes added to commit (use "git add" and/or "git commit -a")
"""

def syntax(msg=None):
  if msg:
    sys.stderr.write('{msg}\n'.format(**locals()))
  sys.stderr.write('{pgm} [-c|--changes|--changed|--modified] [-u|--untracked] [--unmerged] [FILE|DIR ...]\n'.format(pgm=sys.argv[0]))
  exit(1)

def see(expression):
  if verbose:
    sys.stderr.write('>>> {expression}: {value}\n'.format(expression=expression, value=eval(expression)))

(opts, args) = ([], [])
try:
  (opts, args) = getopt.getopt(sys.argv[1:], 'cmuv', ['changes', 'changed', 'modified', 'untracked', 'unmerged', 'verbose'])
except Exception as e:
  syntax(str(e))

verbose = False

section_regexps = {
  'modified': {
     'header': re.compile('^Changes not staged for commit:'),
     'file': re.compile('^\s+modified:\s+(.*)$'),
     'requested': False,
  },
  'unmerged': {
     'header': re.compile('^Unmerged paths:'),
     'file': re.compile('^\s+both modified:\s+(.*)$'),
     'requested': False,
  },
  'untracked': {
     'header': re.compile('^Untracked files:'),
     'file': re.compile('^\t([^( ].*)$'),
     'requested': False,
  },
}

for (opt,arg) in opts:
  if opt in ['-c', '--changes', '--changed', '--modified']:
    section_regexps['modified']['requested'] = not section_regexps['modified']['requested']
  elif opt in ['-u', '--untracked']:
    section_regexps['untracked']['requested'] = not section_regexps['untracked']['requested']
  elif opt in ['--unmerged']:
    section_regexps['unmerged']['requested'] = not section_regexps['unmerged']['requested']
  elif opt in ['-v', '--verbose']:
    verbose = not verbose
  else:
    syntax('Unexpected option: {opt!r}'.format(**locals()))

if not any([section_regexps[section]['requested'] for section in section_regexps.keys()]):
  section_regexps['modified']['requested'] = True # default to modified only

see('section_regexps')

cmd = ['git', 'status'] + args
p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
(stdout, stderr) = p.communicate()
rc = p.wait()
if (rc != 0) or stderr:
  syntax('{cmd} failed: {rc}, {stdout!r}, {stderr!r}'.format(**locals()))

section_end_regexp = re.compile('^\S')

inside = None

for line in stdout.splitlines():
  if section_end_regexp.search(line):
    inside = None
    for section in section_regexps.keys():
      if section_regexps[section]['header'].search(line):
        inside = section

  see('(line, inside)')

  if section_regexps['modified']['requested'] and (inside == 'modified'):
    match = section_regexps['modified']['file'].search(line)
    if match:
      print match.group(1)

  if section_regexps['untracked']['requested'] and (inside == 'untracked'):
    match = section_regexps['untracked']['file'].search(line)
    if match:
      print match.group(1)

  if section_regexps['unmerged']['requested'] and (inside == 'unmerged'):
    match = section_regexps['unmerged']['file'].search(line)
    if match:
      print match.group(1)
