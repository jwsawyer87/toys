#! /usr/bin/python -u

import sys
import getopt
import json
import itertools

def syntax(msg):
    if msg:
        sys.stderr.write(msg + "\n")
    sys.stderr.write("Syntax: %s [--verbose] [--flatten] [--describe] [--file FILENAME] [--depth DEPTH] [path ...]\n" % sys.argv[0])
    exit(1)

def shorten(s, maxLen=80):
    if len(s) > maxLen:
        s = s[:maxLen/2-1] + "..." + s[-(maxLen/2-2):]
    return s

def flatWriter(root, path=[]):
    if type(root) == list:
        for curr in range(len(root)):
            flatWriter(root[curr], path + [str(curr)])
    elif type(root) == dict:
        for curr in sorted(root.keys()):
            flatWriter(root[curr], path + [str(curr)])
    else:
        if type(root) == unicode:
            root = str(root)
        print "/%s %s" % ("/".join(path), repr(root))

def jsonWriter(root):
    print json.dumps(root, indent=2, sort_keys=True)

def process(root, path):
    ret = root
    if path:
        curr = path.pop(0)
        if type(root) == list:
            if curr == "*":
                ret = itertools.imap(process, root, itertools.repeat(path))
            else:
                try:
                    curr = int(curr)
                except Exception as e:
                    sys.stderr.write("Could not cast %s to a list index\n" % repr(curr))
                else:
                    if curr >= len(root):
                        sys.stderr.write("Addressing index %d but there are only %d items\n" % (repr(curr), len(root)))
                    else:
                        ret = root[curr]
        elif type(root) == dict:
            if curr == "*":
                ret = itertools.imap(process, root.values(), itertools.repeat(path))
            elif curr in root:
                ret = root[curr]
            else:
                sys.stderr.write("Addressing non-existent index %s\n" % repr(curr))
        else:
            sys.stderr.write("At %s, expected a list of dictionary but got a %s\n" % (repr(curr), type(root)))
    return ret

def describeWriter(root):
    if type(root) == list:
        print "A %d element list" % len(root)
    elif type(root) == dict:
        print "A %d element dictionary with keys: %s" % (len(root.keys()), ', '.join(sorted(root.keys())))
    else:
        print "A %s" % type(root)

def lop(root, depth):
    if depth <= 0:
        if type(root) == list:
            for (key, value) in enumerate(root):
                root[key] = shorten(json.dumps(value, sort_keys=True))
        elif type(root) == dict:
            for (key, value) in [(key, root[key]) for key in root.keys()]:
                root[key] = shorten(json.dumps(value, sort_keys=True))
    else:
        if type(root) == list:
            itertools.imap(lop, root, itertools.repeat(depth-1))
        elif type(root) == dict:
            for key in root.keys():
                lop(root[key], depth-1)

verbose = False
describe = False
writer = jsonWriter
filename = None
depth = None

(opts, args) = ([], [])
try:
    (opts,args) = getopt.getopt(sys.argv[1:], "v", ["verbose", "flat", "flatten", "describe", "file=", "depth="])
except Exception as e:
    syntax(str(e))

for (opt,arg) in opts:
    if opt in ["-v", "--verbose"]:
        verbose = not verbose
    elif opt in ["--flat", "--flatten"]:
        writer = flatWriter
    elif opt == "--describe":
        writer = describeWriter
    elif opt == "--file":
        filename = arg
    elif opt == "--depth":
        try:
            depth = int(arg)
        except Exception as e:
            syntax("Could not parse `%s %s`: %s" % (opt, arg, e))
    else:
        syntax("Don't know how to handle %s" % repr(opt))

data = None

if filename:
    with open(filename) as stream:
        data = stream.read()
else:
    if sys.stdin.isatty():
        syntax("stdin must be redirected")
    data = sys.stdin.read()

root = None
try:
    root = json.loads(data)
except Exception as e:
    syntax("Could not parse %s: %s" % (repr(shorten(data)), str(e)))

if len(args) == 1:
    args = args[0].strip('/').split('/')

root = process(root, args)

if depth != None:
  lop(root, depth)

writer(root)